/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
    // instantiate pointer variables to different memory mapped registers
	volatile uint32_t *const rcc_ahb2en = (volatile uint32_t *)AHB2ENR_BASE_ADDR;
	volatile uint32_t *const gpioa_mode = (volatile uint32_t *)GPIOA_MODER_ADDR;
	volatile const uint32_t *const gpioa_input = (volatile uint32_t *)GPIOA_IDR_ADDR;
	volatile uint32_t *const gpioa_output = (volatile uint32_t *)GPIOA_ODR_ADDR;
	volatile uint32_t *const gpioa_pupdn = (volatile uint32_t *)GPIOA_PUPDR_ADDR;

	// enable clock for GPIOA
	*rcc_ahb2en |= (1 << 0);

	/* configure modes of desired GPIOA pins */

	// input pins
	// first, clear all the pins
	*gpioa_mode &= ~(0xFFFF << 0);

	// since input configuration is 00, inputs already configured
	// configure output pins
	*gpioa_mode |= (0x55 << 8);

	/* configure pull-up for the chosen input pins */
	// first, clear all the pins
	*gpioa_pupdn &= ~(0xFFFF << 0);

	// then, set them to pull-up
	*gpioa_pupdn |= (0x55 << 0);

	/* note that ODR reset value is 0x0 */
	// set the higher 3 pins to high
	*gpioa_output |= (0x7 << 5);

	/* end of configurations */

	initialise_monitor_handles();

	/* Loop forever */
	for(;;)
	{
		for (uint8_t row_checker = 1; row_checker < 5; ++row_checker)
		{
			// uint8_t variable so only work with the lower 8 bits
			// instead of all 32 bits
			uint8_t g_i = ((*gpioa_input & ~(0xF << 4)));

			switch ( g_i )
			{
			case (0b1111):
				break;

			case (0b1110):
				delay();
				switch (row_checker)
				{
				case (1):
					printf("1\n");
					break;
				case (2):
					printf("4\n");
					break;
				case (3):
					printf("7\n");
					break;
				case (4):
					printf("*\n");
					break;
				}
				break;

			case (0b1101):
				delay();
				switch (row_checker)
				{
				case (1):
					printf("2\n");
					break;
				case (2):
					printf("5\n");
					break;
				case (3):
					printf("8\n");
					break;
				case (4):
					printf("0\n");
					break;
				}
				break;

			case (0b1011):
				delay();
				switch (row_checker)
				{
				case (1):
					printf("3\n");
					break;
				case (2):
					printf("6\n");
					break;
				case (3):
					printf("9\n");
					break;
				case (4):
					printf("#\n");
					break;
				}
				break;

			case (0b0111):
				delay();
				switch (row_checker)
				{
				case (1):
					printf("A\n");
					break;
				case (2):
					printf("B\n");
					break;
				case (3):
					printf("C\n");
					break;
				case (4):
					printf("D\n");
					break;
				}
				break;
			}

			if (row_checker < 4)
				*gpioa_output ^= (0x3 << (row_checker + 3));
		}
		*gpioa_output ^= (0x9 << 4);
	}
}

void delay(void)
{
	for (uint32_t i = 0; i < 50000; ++i);
}

